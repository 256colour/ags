//=============================================================================
// STAGE TWO: Modules
//=============================================================================

Once the source files are distributed between the libraries it is time for
module splitting. Ideally there should be one module (*.h/*.cpp pair) per
logical union of functions, class and logical union of structs or other declarations.
There's also a need to make sure Common lib modules do not have anything strictly
specific to either runtime or editor left in them.

At the moment there are several *.h and *.cpp files that contain abnormal amount
of code, in the first instance - acroom.h and ac.cpp.

While ac.cpp is strictly engine source file, acroom.h is not only shared, but
contains a lot of preprocessor-switch controlled code with function implementations.

//-----------------------------------------------------------------------------
// step 1 -- acroom.h
//-----------------------------------------------------------------------------

Task: split up acroom.h in following substeps:
1. Separate the code under CROOM_NOFUNCTIONS macro control.
2. Separate the code under NO_SAVE_FUNCTIONS macro control.
3. Separate the definition and implementation (if any) from "non-functions"
acroom part into *.cpp.
4. Separate the definition and implementation from "functions" acroom part
into *.cpp. Split any Engine/AGS.Native specific code left.

Result:
    acroom.h            - a common header file, should not be included directly;
    acroom_nofunc.h     - header file for modules that do not need acroom functions;
    acroom_func.h       - header file for modules that do need acroom functions;
    acroom_savefunc.h   - header file for modules that need save functions;
    
    acroom.cpp          - contains function implementations from acroom (except save functions);
    acroom_save.cpp     - contains save functions from acroom;
    
Linkage:
    Common.Lib:         acroom.cpp
    Engine.App:         acroom.cpp (via Common.Lib)
    AGS.Native:         acroom.cpp (via Common.Lib); acroom_save.cpp


//-----------------------------------------------------------------------------
// step 2 -- wgt2allg.h
//-----------------------------------------------------------------------------

Task: split up wgt2allg.h similar to acroom.h (should be easier though):
1. Separate the code under WGT2ALLEGRO_NOFUNCTIONS macro control.
2. Move the implementation to wgt2allg.cpp.

Result:
    wgt2allg.h          - a first part of common header, should not be included directly;
    wgt2allg_2.h        - a second part of common header, should not be included directly;
    wgt2allg_nofunc.h   - header file for modules that do not need wgt2allg functions;
    wgt2allg_func.h     - header file for modules that need wgt2allg functions;
    
    wgt2allg.cpp        - contains function implementations from wgt2allg;
    
Linkage:

    Common.Lib:         wgt2allg.cpp
    Engine.App:         wgt2allg.cpp (via Common.Lib)
    AGS.Native:         wgt2allg.cpp (via Common.Lib)
    

//-----------------------------------------------------------------------------
// step 3 -- splitting Common.Lib headers and modules
//-----------------------------------------------------------------------------

Task: split up headers and source files into logical units.

Some symbols may become exposed to public as a result, but this is a temporary
measure and will be fixed later.

During splitting compiler/parser stuff a lot of declarations and definitions were
moved to Common lib in order to gather a logically bound set of types and functions.
I presume that afterwards a reverse process will take place which will result
in all compiler- and runtime-specific code be moved to Compiler lib and Engine app
respectively; at least that is something one should aim.

//=============================================================================
// Quick notes for future reference
//=============================================================================

WGT2ALLEGRO_NOFUNCTIONS - usage similar to CROOM_NOFUNCTIONS

ALLEGRO_BIG_ENDIAN - must test compilation of libs with this macro defined
(note: "bigend.h" must be included in module if there's this macro in the code)

Question: why does the runtime script interpreter (csrun.cpp) needed to be shared?
What use does it have for AGS.Native?

Engine sends messages to debugger either via files or named pipes;
IAGSEditorDebugger interface is used to make a call.

